<!doctype html>
<html lang="en">
    <head>
        <meta charset="utf-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1" />
        <link rel="icon" href="../images/favicon.png">
        <!--google search verification-->
        <meta name="google-site-verification" content="ssyRAtMxkWxr4l0SjqwduOsQ-hQ65oelQdISVUavsDs" />
        <title>Alyssa Renata - Learning Scala from a Haskell perspective</title>
        <!--firacode font-->
        <link rel="preconnect" href="https://fonts.gstatic.com">
        <link href="https://fonts.googleapis.com/css2?family=Fira+Code&display=swap" rel="stylesheet">
        <!--fontawesome-->
        <link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.5.0/css/all.css" />
        <!--bootstrap-->
        <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.0.0-beta1/dist/css/bootstrap.min.css" rel="stylesheet" integrity="sha384-giJF6kkoqNQ00vy+HMDP7azOuL0xtbfIcaT9wjKHr8RbDVddVHyTfAAsrekwKmP1" crossorigin="anonymous" />
        <!--custom styling-->
        <link rel="stylesheet" type="text/css" href="../css/default.css" />
        <link rel="stylesheet" type="text/css" href="../css/syntax.css" />
        <!--mathjax-->
        <script>
        MathJax = {
          //CommonHTML: {linebreaks: {automatic: true, width: "container"}},
          loader: {load: ['[tex]/bussproofs']}
          tex: {
            packages: {'[+]': ['bussproofs']},
            tags: "all",
            tagSide: "left"
          },
        };
        </script>
        <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
        <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-svg.js"></script>
    </head>
    <body>
      <div id="body">
        <div id="header">
            <div id="logo">
                <a href="../">⊢ Alyssa Renata</a>
            </div>
            <div id="navigation">
                <a href="../">Home</a>
                <a href="../archive.html">Archive</a>
		<a class="fab fa-github" target="_blank" href="https://github.com/alyata"></a>
            </div>
        </div>

        <div id="content">
            <h1> Learning Scala from a Haskell perspective</h1>
            <br>
            <div class="info">
    Posted on January  3, 2021
    
</div>

<p>Next term, we will be doing a group compiler project. We’ve agreed on using
either Scala or Kotlin (we want a JVM language, just not Java). I’m leaning
towards Scala for its emphasis on functional programming, so this will be my
exploration of Scala where I note down interesting things. I will attempt to
make comparisons between Haskell and Scala concepts, and talk about where the
comparison breaks down too. This will mostly act as a reference for myself, but
hopefully other people might find it useful.</p>
<h1 id="sbt---scala-build-tool">SBT - Scala Build Tool</h1>
<p>SBT is a project manager like Stack - it manages the Scala version and
dependencies to be used by a project, as well as provide an interface for
compiling, running and testing your project. Here are the commands and their
stack versions (though they’re mostly the same):</p>
<table>
<thead>
<tr class="header">
<th>SBT</th>
<th>Stack</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>sbt clean</td>
<td>stack clean</td>
</tr>
<tr class="even">
<td>sbt compile</td>
<td>stack build</td>
</tr>
<tr class="odd">
<td>sbt test</td>
<td>stack test</td>
</tr>
<tr class="even">
<td>sbt run</td>
<td>stack run</td>
</tr>
<tr class="odd">
<td>sbt console</td>
<td>stack ghci</td>
</tr>
</tbody>
</table>
<h1 id="values-and-variables">Values and Variables</h1>
<p><code>val</code> identifies an immutable variable (value) whereas <code>var</code> identifies a
mutable one:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode scala"><code class="sourceCode scala"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">val</span> x <span class="op">=</span> <span class="dv">1</span> <span class="co">//immutable</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>x <span class="op">=</span> <span class="dv">10</span> <span class="co">//illegal</span></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a><span class="kw">var</span> y <span class="op">=</span> <span class="dv">0</span> <span class="co">//mutable</span></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>y <span class="op">=</span> <span class="dv">2</span> <span class="co">//legal</span></span></code></pre></div>
<p>In this example, types are implicitly inferred from the values contained
in the variables. However, variable types can be explicitly given if
desired:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode scala"><code class="sourceCode scala"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="kw">val</span> x<span class="op">:</span> <span class="bu">Int</span> <span class="op">=</span> <span class="dv">1</span></span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a><span class="kw">var</span> y<span class="op">:</span> <span class="ex">String</span> <span class="op">=</span> <span class="st">&quot;hello&quot;</span></span></code></pre></div>
<p>The type of a var is fixed upon declaration, but if you allow Scala to
infer the type then it will infer the most specific type possible (it seems).</p>
<p>Sticking to <code>val</code> would be good for doing pure functional programming ala
Haskell, since they cannot be reassigned (although it might still be possible to
assign a mutable object to a val - in which case its not immutable “all the
way”). On the other hand, <code>var</code>s may be reassigned. The new value must have a
type matching the variable, which might be implicitly derived from the original
value.</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode scala"><code class="sourceCode scala"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="kw">var</span> y <span class="op">=</span> <span class="dv">1</span></span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a>y <span class="op">=</span> <span class="st">&quot;hello&quot;</span></span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a>error<span class="op">:</span> <span class="kw">type</span> mismatch<span class="op">;</span></span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a> found   <span class="op">:</span> <span class="ex">String</span><span class="op">(</span><span class="st">&quot;hello&quot;</span><span class="op">)</span></span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true" tabindex="-1"></a> required<span class="op">:</span> <span class="bu">Int</span></span></code></pre></div>
<h1 id="control-structures">Control Structures</h1>
<p>All control structures in Scala return a value <a href="#fn1" class="footnote-ref" id="fnref1" role="doc-noteref"><sup>1</sup></a>, because Scala is an
expression oriented language. This allows for them to be used flexibly either as
“pure” values, or as imperative-style constructs (in which case the <code>unit</code> type
is returned, signifying a non-meaningful value). Although, you can always be
evil by including side-effects <strong>and</strong> return a value at the same time.</p>
<h2 id="if-else-case-expressions">If-Else &amp; Case expressions</h2>
<p>As a first example of flexibility, we can use if-else ala Haskell to define
a value.</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode scala"><code class="sourceCode scala"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="co">// Note to self: remember to bracket your conditional and not use a &quot;then&quot;</span></span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a><span class="kw">val</span> x <span class="op">=</span> <span class="cf">if</span> <span class="op">(</span>y <span class="op">&lt;</span> <span class="dv">10</span><span class="op">)</span> y <span class="cf">else</span> <span class="st">&quot;too big&quot;</span></span></code></pre></div>
<p>The type of <code>x</code> will be inferred to be <code>Any</code>, the most specific type
supertyping both <code>Int</code> and <code>String</code>. If both alternatives had the same type
(e.g. <code>Int</code>), then <code>x</code> will be of type <code>Int</code>.</p>
<p>However, we can also use if-else as an imperative top-level construct:</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode scala"><code class="sourceCode scala"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="co">// Use brackets to run multiple expressions in body</span></span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a><span class="co">// last expression in brackets is the one returned</span></span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a><span class="cf">if</span> <span class="op">(</span>y <span class="op">&lt;</span> <span class="dv">10</span><span class="op">)</span></span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true" tabindex="-1"></a>  <span class="fu">println</span><span class="op">(</span>y<span class="op">)</span></span>
<span id="cb5-5"><a href="#cb5-5" aria-hidden="true" tabindex="-1"></a><span class="cf">else</span> <span class="op">{</span></span>
<span id="cb5-6"><a href="#cb5-6" aria-hidden="true" tabindex="-1"></a>  <span class="fu">println</span><span class="op">(</span><span class="st">&quot;This number is:&quot;</span><span class="op">)</span></span>
<span id="cb5-7"><a href="#cb5-7" aria-hidden="true" tabindex="-1"></a>  <span class="fu">println</span><span class="op">(</span><span class="st">&quot;too big&quot;</span><span class="op">)</span></span>
<span id="cb5-8"><a href="#cb5-8" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>Although we don’t use it, this returns the <code>unit</code> type as printing returns no
meaningful value.</p>
<p>This flexibility also applies for case expressions, which uses the keyword
<code>match</code>:</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode scala"><code class="sourceCode scala"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="co">// Use it like Haskell case expressions</span></span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a><span class="kw">val</span> x <span class="op">=</span> y <span class="cf">match</span> <span class="op">{</span></span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true" tabindex="-1"></a>  <span class="cf">case</span> <span class="dv">1</span> <span class="op">|</span> <span class="dv">2</span> <span class="op">|</span> <span class="dv">3</span> <span class="op">=&gt;</span> <span class="st">&quot;small&quot;</span></span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true" tabindex="-1"></a>  <span class="cf">case</span> <span class="dv">4</span> <span class="op">|</span> <span class="dv">5</span> <span class="op">|</span> <span class="dv">6</span> <span class="op">=&gt;</span> <span class="st">&quot;medium&quot;</span></span>
<span id="cb6-5"><a href="#cb6-5" aria-hidden="true" tabindex="-1"></a>  <span class="cf">case</span> _ <span class="op">=&gt;</span> <span class="st">&quot;large&quot;</span></span>
<span id="cb6-6"><a href="#cb6-6" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb6-7"><a href="#cb6-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-8"><a href="#cb6-8" aria-hidden="true" tabindex="-1"></a><span class="co">// Or use it imperatively</span></span>
<span id="cb6-9"><a href="#cb6-9" aria-hidden="true" tabindex="-1"></a>y <span class="cf">match</span> <span class="op">{</span></span>
<span id="cb6-10"><a href="#cb6-10" aria-hidden="true" tabindex="-1"></a>  <span class="cf">case</span> <span class="dv">1</span> <span class="op">|</span> <span class="dv">2</span> <span class="op">|</span> <span class="dv">3</span> <span class="op">=&gt;</span> <span class="fu">println</span><span class="op">(</span><span class="st">&quot;small&quot;</span><span class="op">)</span></span>
<span id="cb6-11"><a href="#cb6-11" aria-hidden="true" tabindex="-1"></a>  <span class="cf">case</span> <span class="dv">4</span> <span class="op">|</span> <span class="dv">5</span> <span class="op">|</span> <span class="dv">6</span> <span class="op">=&gt;</span> <span class="fu">println</span><span class="op">(</span><span class="st">&quot;medium&quot;</span><span class="op">)</span></span>
<span id="cb6-12"><a href="#cb6-12" aria-hidden="true" tabindex="-1"></a>  <span class="cf">case</span> _ <span class="op">=&gt;</span> <span class="fu">println</span><span class="op">(</span><span class="st">&quot;large&quot;</span><span class="op">)</span></span>
<span id="cb6-13"><a href="#cb6-13" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>One additional feature is to match different subtypes on each case. This is not
possible in Haskell where there is no subtyping. To do this, just add a type
annotation on the pattern match:</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode scala"><code class="sourceCode scala"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a>y <span class="cf">match</span> <span class="op">{</span></span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a>  <span class="cf">case</span> n<span class="op">:</span> <span class="bu">Int</span> <span class="op">=&gt;</span> n <span class="op">+</span> <span class="dv">1</span></span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true" tabindex="-1"></a>  <span class="cf">case</span> str<span class="op">:</span> <span class="ex">String</span> <span class="op">=&gt;</span> str <span class="op">+</span> <span class="st">&quot; + 1&quot;</span></span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true" tabindex="-1"></a>  <span class="cf">case</span> x <span class="op">=&gt;</span> x <span class="co">// otherwise, don't modify it</span></span>
<span id="cb7-5"><a href="#cb7-5" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<h2 id="loops">Loops</h2>
<p>While loops are purely imperative: they always return the <code>unit</code> type. With the
exception of having a (vacuous) return value, they seem to just be good ol’ Java
while loops.</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode scala"><code class="sourceCode scala"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a><span class="cf">while</span> <span class="op">(</span>y <span class="op">&lt;</span> <span class="dv">10</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a>  <span class="fu">println</span><span class="op">(</span>y<span class="op">)</span></span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true" tabindex="-1"></a>  y <span class="op">+=</span> <span class="dv">1</span></span>
<span id="cb8-4"><a href="#cb8-4" aria-hidden="true" tabindex="-1"></a>  y <span class="co">// This return value is ignored, while-loop always evaluates to Unit</span></span>
<span id="cb8-5"><a href="#cb8-5" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>In Scala, the only for loops are foreach loops. They also return the unit type,
although they can pattern match on collection elements unlike Java foreach
loops:</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode scala"><code class="sourceCode scala"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a><span class="kw">val</span> numberPairs <span class="op">=</span> <span class="ex">List</span><span class="op">((</span><span class="dv">1</span><span class="op">,</span><span class="dv">2</span><span class="op">),(</span><span class="dv">3</span><span class="op">,</span> <span class="dv">4</span><span class="op">))</span></span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> <span class="op">((</span>left<span class="op">,</span> right<span class="op">)</span> <span class="op">&lt;-</span> numberPairs<span class="op">)</span> <span class="fu">println</span><span class="op">(</span><span class="ss">s&quot;$left</span><span class="st"> VS </span><span class="ss">$right&quot;</span><span class="op">)</span></span></code></pre></div>
<p>At first glance, this pattern matching notation (with the arrow and all that)
really screams <strong>list comprehension</strong>. Lo and behold, we can use foreach loops
as list comprehensions by adding the keyword <code>yield</code>:</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode scala"><code class="sourceCode scala"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a><span class="kw">val</span> numberPairs <span class="op">=</span> <span class="ex">List</span><span class="op">((</span><span class="dv">1</span><span class="op">,</span><span class="dv">2</span><span class="op">),(</span><span class="dv">3</span><span class="op">,</span> <span class="dv">4</span><span class="op">))</span></span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-3"><a href="#cb10-3" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> <span class="op">((</span>left<span class="op">,</span> right<span class="op">)</span> <span class="op">&lt;-</span> numberPairs<span class="op">)</span> <span class="cf">yield</span> left <span class="op">+</span> right</span></code></pre></div>
<p>This will return a collection of <code>left + right</code>s. And if you really want to be
evil? Do other stuff inside the yield before returning:</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode scala"><code class="sourceCode scala"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> <span class="op">((</span>left<span class="op">,</span> right<span class="op">)</span> <span class="op">&lt;-</span> numberPairs<span class="op">)</span> <span class="cf">yield</span> <span class="op">{</span></span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true" tabindex="-1"></a>  <span class="fu">println</span><span class="op">(</span>left<span class="op">)</span></span>
<span id="cb11-3"><a href="#cb11-3" aria-hidden="true" tabindex="-1"></a>  <span class="fu">println</span><span class="op">(</span>right<span class="op">)</span></span>
<span id="cb11-4"><a href="#cb11-4" aria-hidden="true" tabindex="-1"></a>  x <span class="op">+=</span> lef≡t</span>
<span id="cb11-5"><a href="#cb11-5" aria-hidden="true" tabindex="-1"></a>  left <span class="op">+</span> right</span>
<span id="cb11-6"><a href="#cb11-6" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<h2 id="for-loops-and-do-notation">For loops and do notation</h2>
<p>It turns out, the list comprehension-y feel of for expressions makes a lot of
sense. This is because they are just syntactic sugar for a series of calls to
the following methods:</p>
<ul>
<li><code>List[A].map[B]: (A =&gt; B) =&gt; List[B]</code></li>
<li><code>List[A].flatMap[B]: (A =&gt; Iterable[B]) =&gt; List[B]</code></li>
<li><code>List[A].filter: (A =&gt; Boolean) =&gt; List[A]</code></li>
<li><code>List[A].foreach: (A =&gt; Any) =&gt; Unit</code></li>
</ul>
<p>I’m not sure if these are the actual types of the methods (or if they’re even
syntactically correct), but I think they carry the concept just fine. These
functions are encapsulated in the Iterable trait, which means any class
extending the trait can be for looped (notice that the type of <code>flatMap</code> is the
same as <code>(&gt;&gt;=)</code>). You can also just implement these methods without becoming an
iterable. Anyway, here are <a href="https://stackoverflow.com/questions/1052476/what-is-scalas-yield/1059501#1059501">some
examples</a>
of desugaring that I found on StackOverflow.</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode scala"><code class="sourceCode scala"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a>desugar<span class="op">[</span><span class="cf">for</span><span class="op">(</span>x <span class="op">&lt;-</span> c1<span class="op">;</span> y <span class="op">&lt;-</span> c2<span class="op">;</span> z <span class="op">&lt;-</span>c3<span class="op">)</span> <span class="op">{...}]</span></span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true" tabindex="-1"></a>  ≡ c1<span class="op">.</span><span class="fu">foreach</span><span class="op">(</span>x <span class="op">=&gt;</span> c2<span class="op">.</span><span class="fu">foreach</span><span class="op">(</span>y <span class="op">=&gt;</span> c3<span class="op">.</span><span class="fu">foreach</span><span class="op">(</span>z <span class="op">=&gt;</span> <span class="op">{...})))</span></span>
<span id="cb12-3"><a href="#cb12-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-4"><a href="#cb12-4" aria-hidden="true" tabindex="-1"></a>desugar<span class="op">[</span><span class="cf">for</span><span class="op">(</span>x <span class="op">&lt;-</span> c1<span class="op">;</span> y <span class="op">&lt;-</span> c2<span class="op">;</span> z <span class="op">&lt;-</span> c3<span class="op">)</span> <span class="cf">yield</span> <span class="op">{...}]</span></span>
<span id="cb12-5"><a href="#cb12-5" aria-hidden="true" tabindex="-1"></a>  ≡ c1<span class="op">.</span><span class="fu">flatMap</span><span class="op">(</span>x <span class="op">=&gt;</span> c2<span class="op">.</span><span class="fu">flatMap</span><span class="op">(</span>y <span class="op">=&gt;</span> c3<span class="op">.</span><span class="fu">map</span><span class="op">(</span>z <span class="op">=&gt;</span> <span class="op">{...})))</span></span>
<span id="cb12-6"><a href="#cb12-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-7"><a href="#cb12-7" aria-hidden="true" tabindex="-1"></a>desugar<span class="op">[</span><span class="cf">for</span><span class="op">(</span>x <span class="op">&lt;-</span> c<span class="op">;</span> <span class="cf">if</span> cond<span class="op">)</span> <span class="cf">yield</span> <span class="op">{...}]</span></span>
<span id="cb12-8"><a href="#cb12-8" aria-hidden="true" tabindex="-1"></a>  ≡ c<span class="op">.</span><span class="fu">filter</span><span class="op">(</span>x <span class="op">=&gt;</span> cond<span class="op">).</span><span class="fu">map</span><span class="op">(</span>x <span class="op">=&gt;</span> <span class="op">{...})</span></span>
<span id="cb12-9"><a href="#cb12-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-10"><a href="#cb12-10" aria-hidden="true" tabindex="-1"></a>desugar<span class="op">[</span><span class="cf">for</span><span class="op">(</span>x <span class="op">&lt;-</span> c<span class="op">;</span> y <span class="op">=</span> <span class="op">...)</span> <span class="cf">yield</span> <span class="op">{...}]</span></span>
<span id="cb12-11"><a href="#cb12-11" aria-hidden="true" tabindex="-1"></a>  ≡ c<span class="op">.</span><span class="fu">map</span><span class="op">(</span>x <span class="op">=&gt;</span> <span class="op">(</span>x<span class="op">,</span> <span class="op">...)).</span><span class="fu">map</span><span class="op">((</span>x<span class="op">,</span>y<span class="op">)</span> <span class="op">=&gt;</span> <span class="op">{...})</span></span></code></pre></div>
<p>In particular, notice the parallel between the second example and Haskell’s
do-notation:</p>
<pre><code>for(
  x &lt;- c1
  y &lt;- c2
  z &lt;- c3
) yield {...}

do
  x &lt;- c1
  y &lt;- c2
  z &lt;- c3
  return ...</code></pre>
<p>and their desugarings:</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode scala"><code class="sourceCode scala"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true" tabindex="-1"></a>c1<span class="op">.</span><span class="fu">flatMap</span><span class="op">(</span>x <span class="op">=&gt;</span> c2<span class="op">.</span><span class="fu">flatMap</span><span class="op">(</span>y <span class="op">=&gt;</span> c3<span class="op">.</span><span class="fu">map</span><span class="op">(</span>z <span class="op">=&gt;</span> <span class="op">{...})))</span></span>
<span id="cb14-2"><a href="#cb14-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-3"><a href="#cb14-3" aria-hidden="true" tabindex="-1"></a>c1 <span class="op">&gt;&gt;=</span> <span class="op">(</span>x <span class="op">-&gt;</span> c2 <span class="op">&gt;&gt;=</span> <span class="op">(</span>y <span class="op">-&gt;</span> c3 <span class="op">&gt;&gt;=</span> <span class="op">(</span>z <span class="op">-&gt;</span> <span class="cf">return</span> <span class="op">...)))</span></span></code></pre></div>
<p>These are just monads! They’re even exactly the same length! Although the
condition does seem to be stronger as filter is required as well. From these
examples, I tried to piece together the desugaring mechanism:</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode scala"><code class="sourceCode scala"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true" tabindex="-1"></a>desugar<span class="op">[</span><span class="cf">for</span> <span class="op">(</span>a <span class="op">&lt;-</span> ma<span class="op">;</span> b1<span class="op">;</span> b2<span class="op">;</span> <span class="op">...;</span> bk<span class="op">;</span> <span class="op">...)</span> <span class="op">{...}]</span> </span>
<span id="cb15-2"><a href="#cb15-2" aria-hidden="true" tabindex="-1"></a>  ≡ ma<span class="op">.</span>desugar<span class="op">[</span>b1<span class="op">]</span></span>
<span id="cb15-3"><a href="#cb15-3" aria-hidden="true" tabindex="-1"></a>      <span class="op">.</span>desugar<span class="op">[</span>b2<span class="op">]</span></span>
<span id="cb15-4"><a href="#cb15-4" aria-hidden="true" tabindex="-1"></a>      <span class="op">...</span></span>
<span id="cb15-5"><a href="#cb15-5" aria-hidden="true" tabindex="-1"></a>      <span class="op">.</span>desugar<span class="op">[</span>bk<span class="op">]</span></span>
<span id="cb15-6"><a href="#cb15-6" aria-hidden="true" tabindex="-1"></a>      <span class="op">.</span><span class="fu">foreach</span><span class="op">((</span>a<span class="op">,</span> c1<span class="op">,</span> <span class="op">...,</span> cj<span class="op">)</span> <span class="op">=&gt;</span> desugar<span class="op">[</span><span class="cf">for</span><span class="op">(...)</span> <span class="op">{...}])</span></span></code></pre></div>
<p>where each <code>b</code> has to match either <code>c = expr</code> or <code>if cond</code>. <code>c1, ..., cj</code> is the
list of assigned variable <code>c</code>s that appear in the <code>b</code>s. Now, here’s how <code>b</code>s are
desugared:</p>
<div class="sourceCode" id="cb16"><pre class="sourceCode scala"><code class="sourceCode scala"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true" tabindex="-1"></a><span class="co">// in this context, c1 .. cj are any previous assignments</span></span>
<span id="cb16-2"><a href="#cb16-2" aria-hidden="true" tabindex="-1"></a>desugar<span class="op">[</span>c <span class="op">=</span> expr<span class="op">]</span> ≡ <span class="fu">map</span>   <span class="op">((</span>a<span class="op">,</span> c1<span class="op">,</span> <span class="op">...,</span> cj<span class="op">)</span> <span class="op">=&gt;</span> <span class="op">(</span>a<span class="op">,</span> c1<span class="op">,</span> <span class="op">...,</span> cj<span class="op">,</span> expr<span class="op">))</span></span>
<span id="cb16-3"><a href="#cb16-3" aria-hidden="true" tabindex="-1"></a>desugar<span class="op">[</span><span class="cf">if</span> cond<span class="op">]</span>  ≡ <span class="fu">filter</span><span class="op">((</span>a<span class="op">,</span> c1<span class="op">,</span> <span class="op">...,</span> cj<span class="op">)</span> <span class="op">=&gt;</span> cond<span class="op">)</span></span></code></pre></div>
<p>We also need a base case:</p>
<div class="sourceCode" id="cb17"><pre class="sourceCode scala"><code class="sourceCode scala"><span id="cb17-1"><a href="#cb17-1" aria-hidden="true" tabindex="-1"></a>desugar<span class="op">[</span><span class="cf">for</span> <span class="op">(</span>a <span class="op">&lt;-</span> ma<span class="op">;</span> b1<span class="op">;</span> b2<span class="op">;</span> <span class="op">...;</span> bk<span class="op">)</span> <span class="op">{...}]</span></span>
<span id="cb17-2"><a href="#cb17-2" aria-hidden="true" tabindex="-1"></a>  ≡ ma<span class="op">.</span>desugar<span class="op">[</span>b1<span class="op">]</span></span>
<span id="cb17-3"><a href="#cb17-3" aria-hidden="true" tabindex="-1"></a>      <span class="op">.</span>desugar<span class="op">[</span>b2<span class="op">]</span></span>
<span id="cb17-4"><a href="#cb17-4" aria-hidden="true" tabindex="-1"></a>      <span class="op">...</span></span>
<span id="cb17-5"><a href="#cb17-5" aria-hidden="true" tabindex="-1"></a>      <span class="op">.</span>desugar<span class="op">[</span>bk<span class="op">]</span></span>
<span id="cb17-6"><a href="#cb17-6" aria-hidden="true" tabindex="-1"></a>      <span class="op">.</span><span class="fu">foreach</span><span class="op">((</span>a<span class="op">,</span> c1<span class="op">,</span> <span class="op">...,</span> cj<span class="op">)</span> <span class="op">=&gt;</span> <span class="op">{...})</span></span></code></pre></div>
<p>For loops that <code>yield</code> require the use of <code>flatMap</code> and <code>map</code> instead.</p>
<div class="sourceCode" id="cb18"><pre class="sourceCode scala"><code class="sourceCode scala"><span id="cb18-1"><a href="#cb18-1" aria-hidden="true" tabindex="-1"></a>desugar<span class="op">[</span><span class="cf">for</span> <span class="op">(</span>a <span class="op">&lt;-</span> ma<span class="op">;</span> b1<span class="op">;</span> b2<span class="op">;</span> <span class="op">...;</span> bk<span class="op">;</span> <span class="op">...)</span> <span class="op">{...}]</span> </span>
<span id="cb18-2"><a href="#cb18-2" aria-hidden="true" tabindex="-1"></a>  ≡ ma<span class="op">.</span>desugar<span class="op">[</span>b1<span class="op">]</span></span>
<span id="cb18-3"><a href="#cb18-3" aria-hidden="true" tabindex="-1"></a>      <span class="op">.</span>desugar<span class="op">[</span>b2<span class="op">]</span></span>
<span id="cb18-4"><a href="#cb18-4" aria-hidden="true" tabindex="-1"></a>      <span class="op">...</span></span>
<span id="cb18-5"><a href="#cb18-5" aria-hidden="true" tabindex="-1"></a>      <span class="op">.</span>desugar<span class="op">[</span>bk<span class="op">]</span></span>
<span id="cb18-6"><a href="#cb18-6" aria-hidden="true" tabindex="-1"></a>      <span class="op">.</span><span class="fu">flatMap</span><span class="op">((</span>a<span class="op">,</span> c1<span class="op">,</span> <span class="op">...,</span> cj<span class="op">)</span> <span class="op">=&gt;</span> desugar<span class="op">[</span><span class="cf">for</span><span class="op">(...)</span> <span class="op">{...}])</span></span>
<span id="cb18-7"><a href="#cb18-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb18-8"><a href="#cb18-8" aria-hidden="true" tabindex="-1"></a>desugar<span class="op">[</span><span class="cf">for</span> <span class="op">(</span>a <span class="op">&lt;-</span> ma<span class="op">;</span> b1<span class="op">;</span> b2<span class="op">;</span> <span class="op">...;</span> bk<span class="op">)</span> <span class="cf">yield</span> <span class="op">{...}]</span></span>
<span id="cb18-9"><a href="#cb18-9" aria-hidden="true" tabindex="-1"></a>  ≡ ma<span class="op">.</span>desugar<span class="op">[</span>b1<span class="op">]</span></span>
<span id="cb18-10"><a href="#cb18-10" aria-hidden="true" tabindex="-1"></a>      <span class="op">.</span>desugar<span class="op">[</span>b2<span class="op">]</span></span>
<span id="cb18-11"><a href="#cb18-11" aria-hidden="true" tabindex="-1"></a>      <span class="op">...</span></span>
<span id="cb18-12"><a href="#cb18-12" aria-hidden="true" tabindex="-1"></a>      <span class="op">.</span>desugar<span class="op">[</span>bk<span class="op">]</span></span>
<span id="cb18-13"><a href="#cb18-13" aria-hidden="true" tabindex="-1"></a>      <span class="op">.</span><span class="fu">map</span><span class="op">((</span>a<span class="op">,</span> c1<span class="op">,</span> <span class="op">...,</span> cj<span class="op">)</span> <span class="op">=&gt;</span> <span class="op">{...})</span></span></code></pre></div>
<h1 id="functions-vs-methods">Functions VS Methods</h1>
<p>In Scala, functions are values but methods are not. Functions can be defined
using anonymous functions</p>
<div class="sourceCode" id="cb19"><pre class="sourceCode scala"><code class="sourceCode scala"><span id="cb19-1"><a href="#cb19-1" aria-hidden="true" tabindex="-1"></a><span class="kw">val</span> add <span class="op">=</span> <span class="op">(</span>x<span class="op">:</span> <span class="bu">Int</span><span class="op">,</span> y<span class="op">:</span> <span class="bu">Int</span><span class="op">)</span> <span class="op">=&gt;</span> x <span class="op">+</span> y</span>
<span id="cb19-2"><a href="#cb19-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-3"><a href="#cb19-3" aria-hidden="true" tabindex="-1"></a><span class="co">// If you want a curried version:</span></span>
<span id="cb19-4"><a href="#cb19-4" aria-hidden="true" tabindex="-1"></a><span class="kw">val</span> add <span class="op">=</span> <span class="op">(</span>x<span class="op">:</span> <span class="bu">Int</span><span class="op">)</span> <span class="op">=&gt;</span> <span class="op">(</span>y<span class="op">:</span> <span class="bu">Int</span><span class="op">)</span> <span class="op">=&gt;</span> x <span class="op">+</span> y</span></code></pre></div>
<p>or placeholder syntax.<a href="#fn2" class="footnote-ref" id="fnref2" role="doc-noteref"><sup>2</sup></a></p>
<div class="sourceCode" id="cb20"><pre class="sourceCode scala"><code class="sourceCode scala"><span id="cb20-1"><a href="#cb20-1" aria-hidden="true" tabindex="-1"></a><span class="kw">val</span> add <span class="op">=</span> <span class="op">(</span>_<span class="op">:</span> <span class="bu">Int</span><span class="op">)</span> <span class="op">+</span> <span class="op">(</span>_<span class="op">:</span> <span class="bu">Int</span><span class="op">)</span></span></code></pre></div>
<p>On the other hand, methods are defined using the <code>def</code> keyword. However, they
cannot be assigned to a <code>val</code> or <code>var</code> as they are not values.</p>
<div class="sourceCode" id="cb21"><pre class="sourceCode scala"><code class="sourceCode scala"><span id="cb21-1"><a href="#cb21-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> <span class="fu">addM</span><span class="op">(</span>x<span class="op">:</span> <span class="bu">Int</span><span class="op">,</span> y<span class="op">:</span> <span class="bu">Int</span><span class="op">)</span> <span class="op">=</span> x <span class="op">+</span> y</span>
<span id="cb21-2"><a href="#cb21-2" aria-hidden="true" tabindex="-1"></a><span class="kw">val</span> add <span class="op">=</span> addM</span>
<span id="cb21-3"><a href="#cb21-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-4"><a href="#cb21-4" aria-hidden="true" tabindex="-1"></a>error<span class="op">:</span> missing argument list <span class="cf">for</span> method addM</span>
<span id="cb21-5"><a href="#cb21-5" aria-hidden="true" tabindex="-1"></a>       Unapplied methods are only converted to functions when a function <span class="kw">type</span> is</span>
<span id="cb21-6"><a href="#cb21-6" aria-hidden="true" tabindex="-1"></a>       expected<span class="op">.</span></span>
<span id="cb21-7"><a href="#cb21-7" aria-hidden="true" tabindex="-1"></a>       You can make <span class="kw">this</span> conversion explicit by writing `addM _` or `<span class="fu">addM</span><span class="op">(</span>_<span class="op">,</span>_<span class="op">)</span>` </span>
<span id="cb21-8"><a href="#cb21-8" aria-hidden="true" tabindex="-1"></a>       instead of `addM`<span class="op">.</span></span></code></pre></div>
<p>As mentioned in the error message, methods cannot be assigned to variables, but
they can be converted to functions. This conversion can be done by either adding
an underscore in front of the function (<code>addM _</code>) or by applying the method to
placeholders. The former method is called
<a href="https://tpolecat.github.io/2014/06/09/methods-functions.html">η-expansion</a>. We
can see how it works by checking the type:</p>
<div class="sourceCode" id="cb22"><pre class="sourceCode scala"><code class="sourceCode scala"><span id="cb22-1"><a href="#cb22-1" aria-hidden="true" tabindex="-1"></a><span class="op">:</span><span class="kw">type</span> addM _</span>
<span id="cb22-2"><a href="#cb22-2" aria-hidden="true" tabindex="-1"></a><span class="op">(</span><span class="bu">Int</span><span class="op">,</span> <span class="bu">Int</span><span class="op">)</span> <span class="op">=&gt;</span> <span class="bu">Int</span></span>
<span id="cb22-3"><a href="#cb22-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-4"><a href="#cb22-4" aria-hidden="true" tabindex="-1"></a><span class="co">// Curried version:</span></span>
<span id="cb22-5"><a href="#cb22-5" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> <span class="fu">addM</span><span class="op">(</span>x<span class="op">:</span> <span class="bu">Int</span><span class="op">)(</span>y<span class="op">:</span> <span class="bu">Int</span><span class="op">)</span> <span class="op">=</span> x <span class="op">+</span> y</span>
<span id="cb22-6"><a href="#cb22-6" aria-hidden="true" tabindex="-1"></a><span class="op">:</span><span class="kw">type</span> addM _</span>
<span id="cb22-7"><a href="#cb22-7" aria-hidden="true" tabindex="-1"></a><span class="bu">Int</span> <span class="op">=&gt;</span> <span class="op">(</span><span class="bu">Int</span> <span class="op">=&gt;</span> <span class="bu">Int</span><span class="op">)</span></span></code></pre></div>
<p>When passing in a method to a higher-order function, it will automatically
expand it for you without having to use an underscore.</p>
<section id="footnotes" class="footnotes footnotes-end-of-document" role="doc-endnotes">
<hr />
<ol>
<li id="fn1"><p>This is not technically correct as using <code>return</code> is specifically reserved
for functions, but its nice to think about it like that.<a href="#fnref1" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn2"><p>I have to explicitly type the placeholders as there’s no context for their
type here. When passing a placeholdered expression to a higher-order function,
Scala should be able to infer the placeholders’ types, removing the need for
this.<a href="#fnref2" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
</ol>
</section>

        </div>
        <div id="footer">
          <!-- <div id="github-link"> -->
          <!--   <a class='fab fa-github' target="_blank" -->
          <!--      href='https://github.com/alyata' /> -->
          <!-- </div> -->
          <div id="hakyll-link">
            Site proudly generated by 
            <a target="_blank" href="http://jaspervdj.be/hakyll">Hakyll</a>
          </div>
        </div>
      </div>
    </body>
</html>
